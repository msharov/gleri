<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>GLERI - Image Viewer Tutorial</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <link rel="index" type="text/xhtml+xml" href="index.html" />
    <link rel="prev" type="text/xhtml+xml" href="tuthello.html" />
    <meta http-equiv="Content-Type" content="text/xhtml+xml; charset=ISO-8859-1" />
    <meta name="Description" content="A tutorial creating a functional image viewer" />
    <meta name="Keywords" content="OpenGL, remote, API, tutorial, image viewer" />
    <meta name="author" content="Mike Sharov" />
    <meta name="date" content="2013-11-22" />
</head>
<body>
<div id="pagectr"><div id="header">

<h1>Image Viewer</h1>

</div><div id="content">
<p>
This tutorial illustrates the loading and use of resources such as
textures and vertex buffers in 2D drawing using default shaders. Examples
include drawing solid primitives, images and subimages, clipping, scaling,
and offscreen rendering. You are expected to have read the previous
tutorial, <a href="tuthello.html">"Hello world!"</a>; the topics covered
there will not be repeated. The source code for the image viewer is in
<tt>tut/rgliv</tt>. It is built by default when you build GLERI, and
can be run as <tt>tut/rgliv/rgliv test/pgcat.jpg</tt>. Please read the
heavily commented source for full details on the image viewer operations.
This document explains only the GLERI-specific parts.
</p>

<h2>Resource Loading</h2>
<p>
Buffers, textures, fonts, datapaks, shaders, and framebuffers are
collectively called resources and can be loaded using <tt>Load</tt>
calls in <tt>PRGL</tt>. There are three versions - first to load directly
from data you specify by pointer, second to load from file, third to
load from a datapak. (Datapaks are not covered in this tutorial, they
are <tt>.cpio.gz</tt> archives you can send over in a single call. Handy
for aggregating all your resources together for faster loading)
</p><p>
When connecting to <tt>gleris</tt> over a TCP socket, the resource
data is always sent over the wire. When a local socket is used, files
are sent by directly passing their file descriptors. This ensures that
you do not suffer the copy penalty when running locally. Optimizing an
application for best network performance can be tricky, and this image
viewer does not really try. Generating thumbnails locally and keeping
them stored somewhere in <tt>.cache</tt> can be good optimizations to
avoid excessive network traffic.
</p><pre>
void CImageViewer::OnInit (void)
{
    CWindow::OnInit();
    Open ("GLERI Image Viewer", WinInfo (0,0,800,600,0,0x33,0,WinInfo::MSAA_OFF,WinInfo::type_Normal,WinInfo::state_Fullscreen));
    TexParameter (G::Texture::MIN_FILTER, G::Texture::LINEAR);
    TexParameter (G::Texture::MAG_FILTER, G::Texture::LINEAR);
    static const coord_t c_Vertices[] = {
        VGEN_TSRECT (0,0, c_EntryWidth,c_EntryWidth),
        0,2, 0,15, 15,15, 15,2, 8,2, 7,0, 1,0,
        0,0, 0,15, 15,15, 15,2, 13,0, 13,2, 15,2, 13,0
    };
    _vertices = BufferData (G::ARRAY_BUFFER, c_Vertices, sizeof(c_Vertices));
    _thumbsDepth = CreateDepthTexture (c_CacheWidth, c_CacheHeight);
    _thumbs = CreateTexture (G::TEXTURE_2D, c_CacheWidth, c_CacheHeight, 0, G::Pixel::RGBA);
    _thumbsFb = CreateFramebuffer (_thumbsDepth, _thumbs);
    _caching.ImageH = _caching.ImageW = 16;
    for (_caching.ThumbIndex = 0; _caching.ThumbIndex &lt; 2; ++_caching.ThumbIndex)
        DrawThumbCache (_thumbsFb);
    LoadEntry();
}
enum {
    VRENUM (EntrySquare, 4),
    VRENUM (FolderIcon, 7),
    VRENUM (FileIcon, 8)
};
</pre><p>
You can load resources only after you open the target window in
<tt>OnInit</tt>. In this example the long form of <tt>Open</tt> is
used in order to make the viewer window fullscreen for most comfortable
viewing.  Other parameters of note are the OpenGL version, here set to
<tt>0x33,0</tt> meaning minimum GL 3.3, with no maximum version. GLERI
always requires at least 3.3, core profile, so you would set a higher
version if you use its features, such as tesselation shaders. A maximum
version can be set to avoid forward compatibility issues.
</p><p>
<tt>TexParameter</tt>, like its OpenGL equivalent, sets various parameters
for textures. For the image viewer it is nice to enable linear filtering
to smooth the images when zooming.
</p><p>
The first resource loaded is a vertex buffer containing coordinates
for primitives. Three primitives are specified in a single buffer,
for efficiency. The first is the selection rectangle, specified in
4 vertices generated by the <tt>VGEN_TSRECT</tt> macro. A macro is
used because specifying a primitive in OpenGL can be rather tricky.
These issues are not specific to GLERI, but are applicable to anything
that uses OpenGL:
</p><p>
First remember that points must be specified in a counter-clockwise
direction. Even though you are only drawing in 2D, OpenGL treats all
primitives as 3D, and will see a clockwise polygon as facing backward.
Backward-facing polygons are not drawn.
</p><p>
The same set of vertices will render differently depending on what
type of primitive you are drawing. Here a triangle strip will be
used, a filled primitive, so you must specify the far boundary point
one past the pixel you intend to fill, taking into account that the
last row and column of pixels will not be rendered. If this were
rendered as a line strip, the line will go directly through the
vertices. Because vertex buffers contain no information about what
type of primitive is being drawn (and can, in fact, be used to draw
multiple ones over the same vertices), there is no way to work around
this issue in the backend.
</p><p>
The final complication is that OpenGL uses a left handed coordinate
system with y increasing upward from the bottom of the screen, while
pretty much everybody else wants y to increase downward from the
top. GLERI inverts the y by default, putting <tt>0,0</tt> in the top
left corner. Unfortunately, when filling primitives, the "far edge" is
determined by OpenGL to be the top one, so that when you draw a triangle
strip through points <tt>0,0, 0,10, 10,0, 10,10</tt>, you will actually
get a 9x9 square at <tt>0,<b>1</b></tt>. If only life were simpler...
</p><p>
And that's why there are the <tt>VGEN</tt> macros for
defining rectangular areas for line loops, triangle strips,
and triangle fans - <tt>VGEN_LLRECT</tt>, <tt>VGEN_TSRECT</tt>,
and <tt>VGEN_TFRECT</tt>, taking position and dimensions,
and emitting the correct vertex sequence for each. Tesselated
filled disks are available as <tt>VGEN_TFCIRCLE_10(x,y,r)</tt>,
<tt>VGEN_TFCIRCLE_18</tt>, and <tt>VGEN_TFCIRCLE_34</tt>,
line circles as <tt>VGEN_LLCIRCLE_{8,16,32}</tt>, and ellipses as
<tt>VGEN_TFELLIPSE_{10,18,34}(x,y,rx,ry)</tt> and
<tt>VGEN_LLELLIPSE_{8,16,32}</tt>.
The numbers in the macro name specify the number of vertices. These
macros are defined in <tt>gleri/gldefs.h</tt>.
</p><p>
The other two primitives are line loops for drawing default entry icons,
one line in 7 points for the folder icon, and one line in 8 points for
the file icon. These are drawn in the folder view when thumbnails are
unavailable. Because it can be tedious and error-prone to keep track
of offsets and sizes of each vertex object in a combined vertex buffer
(using which is common because it reduces the number of buffer binding
operations and improves GPU cache locality), there is the VRENUM macro
for defining v_NameOffset and v_NameSize constants in an enum, just as
you see above. These can then be passed to primitive drawing commands.
</p><p>
The second resource created is the thumbnail cache texture and the
framebuffer used to draw onto it. Note that both the color and depth
texture are required, even though only 2D rendering is done. The
color texture is specified as RGBA to make the border around the
thumbnail transparent.
</p><p>
Then, the two default thumbnails are rendered into slots 0 and 1.
DrawThumbCache is defined similarly to the regular <tt>OnDraw</tt>,
with a double-called template, so macros are provided for this purpose.
<tt>DRAWFBDECL(ThumbCache);</tt> is placed in the class declaration,
and <tt>DRAWFBIMPL(CImageViewer,ThumbCache) {}</tt> is used to define
the body. Drawing is done just as in <tt>OnDraw</tt>, through the
<tt>drw</tt> object.
</p><pre>
_loadingImg = LoadTexture (G::TEXTURE_2D, CurEntry().Name());
</pre><p>
Finally, <tt>LoadEntry</tt> is called to load the initial image or
folder. <tt>LoadEntry</tt> calls <tt>LoadTexture</tt> as above with
the image filename. When gleris finishes loading the texture, it
will send a resource info back to the client.
</p>

<h2>Resource Info Events</h2>
<pre>
void CImageViewer::OnTextureInfo (goid_t tid, const G::Texture::Header&amp; ih)
{
    CWindow::OnTextureInfo (tid, ih);
    if (tid == _loadingImg) {
        _iw = ih.w; _ih = ih.h;
        if (_img != G::GoidNull)
            FreeTexture (_img);
        _img = _loadingImg;
        _loadingImg = G::GoidNull;
        _view = ImageView;
    } else if (tid == _caching.Image) {
        _caching.ImageW = ih.w; _caching.ImageH = ih.h;
        if (_caching.FileIndex &lt; _files.size()) {
            DrawThumbCache (_thumbsFb);
            _files[_caching.FileIndex].SetThumbIndex (_caching.ThumbIndex);
        }
        FreeTexture (_caching.Image);
        _caching.Image = G::GoidNull;
        BeginThumbUpdate();
    }
    OnKey ('m');
}
</pre><p>
When a resource is loaded, gleris sends a resource info event to client.
Here is the the texture info handler. <tt>G::Texture::Header</tt>
is defined in <tt>gleri/gldefs.h</tt>. Here only the image dimensions
are of interest. A separate texture object is used to keep the image
currently being loaded to avoid flicker when changing images.
</p><p>
Here you also see the receipt of the image loaded for thumbnailing.
<tt>DrawThumbCache</tt> is then called with parameters in
<tt>_caching</tt> to generate the thumbnail, followed by freeing the
image and continuing thumbnailing.
</p>

<h2>Drawing</h2>
<pre>
ONDRAWIMPL(CImageViewer)::OnDraw (Drw&amp; drw) const
{
    CWindow::OnDraw (drw);
    if (_view == ImageView) {
        drw.Clear (color_ImageViewBackground);
        if (_img != G::GoidNull) {
            drw.Scale (_iscale, _iscale);
            drw.Image (_ix/_iscale, _iy/_iscale, _img);
        }
    } else {
        drw.Clear (color_FolderViewBackground);
        const coord_t filenameX = Font()-&gt;Width(), filenameY = c_EntryHeight-Font()-&gt;Height()*5/2;
        drw.Color (color_FolderViewText);
        drw.VertexPointer (_vertices);
        for (unsigned y = 0, ie = _firstentry; y &lt;= Info().h-c_EntryHeight; y += c_EntryHeight) {
            for (unsigned x = 0; x &lt;= Info().w-c_EntryWidth; ++ie, x += c_EntryWidth) {
                drw.Viewport (x,y,c_EntryWidth,c_EntryHeight);
                if (ie &gt;= _files.size())
                    return;
                if (ie == _selection) {
                    drw.Color (color_FolderViewSelection);
                    drw.TriangleStrip (v_EntrySquareOffset, v_EntrySquareSize);
                    drw.Color (color_FolderViewText);
                }
                uint8_t thumbIndex = _files[ie].ThumbIndex();
                drw.Sprite (c_ThumbX, c_ThumbY, _thumbs, CacheThumbX (thumbIndex), CacheThumbY (thumbIndex), c_ThumbWidth, c_ThumbHeight);
                const char* filename = _files[ie].Name();
                drw.Text (max (filenameX, (c_EntryWidth-Font()-&gt;Width(filename))/2), filenameY, _files[ie].Name());
            }
        }
    }
}
</pre><p>
Here a variety of drawing methods is illustrated. First is the simple
image drawing with the <tt>Image</tt> call that draws the full image at
given coordinates. The transformation matrix for the default shaders
can be manipulated by the <tt>Scale</tt> and <tt>Offset</tt> calls to
stretch and move objects on the screen. Here such scaling is used to
zoom into the image.
</p><p>
Both the image view and the folder thumbnail views are drawn, switched on
<tt>_view</tt>. In the folder view, thumbnail and filename are drawn for
each entry. The thumbnail is drawn with the <tt>Sprite</tt> call, that
takes the screen position, texture, and the area from the texture to draw.
The thumbnail cache is a single large texture with all the thumbnails in
a grid, and the appropriate area is selected from it. Text is then drawn
centered under the thumbnail, just like in the previous tutorial.
</p><p>
To keep the text from overflowing outside the entry box the
<tt>Viewport</tt> is set to the entry rectangle. This offsets all
primitives to the viewport as well as clips them to its edges.
</p><p>
The bright selection rectangle is drawn using a triangle strip
defined in the <tt>_vertices</tt> buffer. To draw it you must
first bind a vertex buffer with <tt>VertexPointer</tt>,
and then call the appropriate primitive function.
<tt>TriangleStrip(v_EntrySquareOffset,v_EntrySquareSize)</tt> means
"draw a triangle strip using v_EntrySquareSize vertices, starting at
vertex v_EntrySquareOffset, from the currently selected vertex buffer".
</p><p>
Both <tt>VertexPointer</tt> and <tt>TriangleStrip</tt> are convenience
functions for working with default shaders. For your own shaders
you would set parameters manually with the <tt>Parameter</tt>
call that is the equivalent of <tt>glVertexAttribPointer</tt>,
and then use <tt>DrawArrays</tt> and friends to render a specified
primitive type. <tt>TriangleStrip(0,4)</tt> is equivalent to
<tt>DrawArrays(G::TRIANGLE_STRIP,0,4)</tt>, defined because this is
what you use most of the time for 2D drawing. Drawing by index with
<tt>DrawElements</tt>, instancing, and indirect buffers are advanced
OpenGL topics. Please consult OpenGL tutorials on the appropriate uses
for those.
</p><pre>
DRAWFBIMPL(CImageViewer,ThumbCache)
{
    drw.VertexPointer (_vertices);
    drw.Viewport (CacheThumbX (_caching.ThumbIndex), CacheThumbY (_caching.ThumbIndex), c_ThumbWidth, c_ThumbHeight);
    drw.Clear (color_ThumbBackground);
    drw.Color (color_FolderViewText);
    float scale = min (float(c_ThumbWidth)/_caching.ImageW, float(c_ThumbHeight)/_caching.ImageH);
    drw.Scale (scale, scale);
    if (_caching.ThumbIndex == CFolderEntry::Folder)
        drw.LineLoop (v_FolderIconOffset, v_FolderIconSize);
    else if (_caching.ThumbIndex == CFolderEntry::Image)
        drw.LineLoop (v_FileIconOffset, v_FileIconSize);
    else if (_caching.Image != G::GoidNull)
        drw.Image ((c_ThumbWidth/scale-_caching.ImageW)/2,
                   (c_ThumbWidth/scale-_caching.ImageH)/2,
                   _caching.Image);
}
</pre><p>
Offscreen drawing is implemented exactly like the onscreen
<tt>OnDraw</tt>, but with a different suffix on the names. The
standard draw command creation code is also generated by macros, with
the above code implementing the <tt>DrawThumbCache</tt> call and the
<tt>OnDrawThumbCache</tt> template containing drawing code.
</p><p>
Here offscreen rendering is used to draw thumbnails onto the cache
texture. Default thumbnails are drawn as line loops onto the first two
slots. Just as in the <tt>OnDraw</tt> above, the primitives are drawn
with <tt>VertexPointer</tt>/<tt>LineLoop</tt>, scaling up from 16x16,
and the loaded image is drawn, scaling down to thumb size.
</p><p>
<tt>OnDraw</tt> draws to a double-buffered surface, so each call must
render an entire frame before the buffers are swapped. With offscreen
rendering, incremental drawing is possible. Here, only one thumbnail is
drawn per call.
</p>
</div></div>
</body>
</html>
